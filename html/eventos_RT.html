<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html>
<head>
<meta name="author of conversion perl script" content="Hartmut Pohlheim" />
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />

<meta name="description" content=" EVENTOSRT Deteccion de Initial Contact y End Contact en Tiempo Real con acelerometro en " />
<meta name="keywords" content=" localmaxima alg_det_event " />
<title>Documentation of  eventos_RT</title>
</head>
<body >
<h1 >Documentation of  eventos_RT</h1>
<hr size="3" noshade="noshade" />

<p align="center">Global Index (<a href = "indexsgf.html">short</a> | <a href = "indexlgf.html">long</a>)
 | <a href="Contentssilop.html">Local contents</a>
 | Local Index (<a href = "indexslfsilop.html">short</a> | <a href = "indexllfsilop.html">long</a>)
</p>

<hr size="3" noshade="noshade" />
<h2 >Function Synopsis</h2>
<pre>[retardo_hs,retardo_to]=eventosRT(ah,av,reset)</pre>
<hr size="3" noshade="noshade" />
<h2 >Help text</h2>
<pre>
 EVENTOSRT Deteccion de Initial Contact y End Contact en Tiempo Real con acelerometro en
 el COG

 EVENTOSRT Esta funcion permite ser llamada de forma consecutiva para obtener los instantes de eventos de Contacto
 Inicial. Es IMPRESCINDIBLE que la señal esté siendo capturada a 100HZ. Es necesario reinicializar las variables
 persistentes para cada experimento nuevo. 
 
 Syntax:  [retardo_hs,retardo_to] = eventos_RT(ah,av,reset)

 Input parameters:
    ah        - Valor de la ultima muestra de aceleracion antero-posterior
    av        - Valor de la ultima muestra de aceleracion vertical
    reset     - Si se usa un tercer parámetro, reinicia el proceso de captura y procesamiento.

 Output parameters:
    retardo_hs   - 0 si no se ha detectado evento de Initial Contact. N &gt; 0 si se ha detectado
                   evento. En este caso N indica el retardo o distancia en muestras a la
                   estimacion del evento respecto al instante actual.
    retardo_to   - 0 si no se ha detectado evento de End Contact. N &gt; 0 si se ha detectado
                   evento. En este caso N indica el retardo o distancia en muestras a la
                   estimacion del evento respecto al instante actual.

 Examples:

 See also: <a class="mfun" href="eventoscogrecto.html">eventosCOGrecto</a>
</pre>
<hr size="3" noshade="noshade" />
<h2 >Cross-Reference Information</H2>
<table border="0" width="100%">
<tr align="left">
<th width="50%">This function calls</th>
<th width="50%">This function is called by</th>
</tr>
<tr valign="top"><td>
<ul>
<li><a class="mfun" href="private/localmaxima.html">localmaxima</a></li>
</ul>
</td><td>
<ul>
<li><a class="mfun" href="private/alg_det_event.html">alg_det_event</a></li>
</ul>
</td>
</tr>
</table>
<hr size="3" noshade="noshade" />
<h2 >Listing of function eventos_RT</h2>
<pre>


<em class="mcom">% Author:   Javi</em>
<em class="mcom">% History:  04.01.2008  file created</em>
<em class="mcom">%           16.01.2008  Inclusion de End Contact</em>
<em class="mcom">%                       Añadido parámetro reset</em>
<em class="mcom">%                       Incorporada a la toolbox(Diego)</em>
<em class="mcom">%           18.01.2008  Bug corregido, eliminado el uso de persistent durante el reset.</em>
<em class="mcom">%           18.01.2008  bug corregido, se cambia la llamada a picos por <a class="mfun" href="private/localmaxima.html">localmaxima</a>, y se comprueba tamaño de pmax</em>

function[retardo_hs,retardo_to]=eventosRT(ah,av,reset)

filtro=[0.0365 0.0374 0.0375 0.0382 0.0381 0.0385 0.0381 0.0382 0.0375 0.0374 0.0365]; <em class="mcom">%filtro de fase lineal con frecuancia de corte 2Hz</em>
TROZO=200; <em class="mcom">%constante que indica el número de muestras que se toman como máximo en RT</em>
INTERVALO=11; <em class="mcom">%constante que indica el nº de muestras positivas que debe haber anteriormente al zero-crossing</em>

<em class="mcom">%Paso 1: Tomar datos de individuo y paseo</em>
persistent pers_datah; <em class="mcom">%señal de aceleración anteroposterior</em>
persistent pers_data2; <em class="mcom">%señal filtrada</em>
persistent pers_datav; <em class="mcom">%señal de aceleración vertical</em>
persistent pers_indice_ultimo_hs; <em class="mcom">%indice del ultimo hs</em>

if (nargin&gt;2)  <em class="mcom">%Implementacion del reset</em>
	pers_datah=[];		
	pers_data2=[];
	pers_datav=[];
end

if(isempty(pers_indice_ultimo_hs))
   pers_indice_ultimo_hs=0; 
end
if(length(pers_datah)==TROZO)
    aux=2;
    pers_indice_ultimo_hs=pers_indice_ultimo_hs-1;
else
    aux=1;
end
pers_datah=[pers_datah(aux:end) ah]; <em class="mcom">%trozo de las ultimas 200 muestras de aceleracion antero-posterior</em>
pers_datav=[pers_datav(aux:end) av]; <em class="mcom">%trozo de las ultimas 200 muestras de aceleracion vertical</em>

<em class="mcom">%Calculo de la señal filtrada</em>
L=min([length(pers_datah),length(filtro)]); <em class="mcom">%longitud de la convolucion</em>
valor=0; <em class="mcom">%variable en la que se guardará la nueva muestra de señal filtrada</em>
for j=1:L
    valor=valor+filtro(j)*pers_datah(end-j+1); 
end
pers_data2=[pers_data2(aux:end) valor]; <em class="mcom">%trozo de las ultimas 200 muestras de la señal filtrada</em>

retardo_hs=0; <em class="mcom">%en principio no hay evento</em>
retardo_to=0;
if(length(pers_datah)&gt;INTERVALO)
   T=0;
   if(pers_data2(end)&lt;0 &amp;&amp; pers_data2(end-1)&gt;0)
      <em class="mcom">%se produjo un zero-crossing</em>
      
      <em class="mcom">%calcular periodo de la señal</em>
      if(aux==2) <em class="mcom">%si tenemos un trozo de 200</em>
       auto=xcorr(pers_datah,TROZO,'unbiased');
       auto=auto(TROZO+1:end);
       pmax=<a class="mfun" href="private/localmaxima.html">localmaxima</a>(auto'.*(auto'&gt;0),20);
        if(length(pmax)&lt;2)
            T=0; <em class="mcom">%no tenemos informacion suficiente para calcular periodo</em>
        else
           d=diff(pmax);
           [aux1,aux2]=sort(abs(mean(d)-d));
           T=d(aux2(1));
        end
      end
      flag=0;
      <em class="mcom">%hay cambio de signo. Tenemos que comprobar si se trata de un ZC real</em>
      if(T==0)
          <em class="mcom">%no hay datos de periodo. Hay que comprobar si hay INTERVALO muestras</em>
          <em class="mcom">%positivas por la izquierda o menos</em>
          if(sum(sign(pers_data2(end-INTERVALO+1:end-1)))==INTERVALO-1)
              <em class="mcom">%se trata de un ZC</em>
              flag=1;<em class="mcom">%lo indicamos con un flag</em>
          end
      else
          <em class="mcom">%tenemos informacion de periodo</em>
          ultimo=find(pers_data2&lt;0);
          if (length(ultimo)&gt;1) <em class="mcom">%By Diego</em>
               distancia=ultimo(end)-ultimo(end-1)-1; <em class="mcom">%nº de muestras positivas</em>
               norma=distancia/T;
               if(norma&gt;0.2)
                  <em class="mcom">%se trata de un ZC</em>
                  flag=1; <em class="mcom">%lo indicamos con un flag</em>
               end
	  end
      end
      if(flag==1) <em class="mcom">%hubo un ZC</em>
          <em class="mcom">%Seleccionamos la ventana donde buscamos el pico</em>
          <em class="mcom">%El retardo introducido por el filtro es de 5 muestras. Tomamos</em>
          <em class="mcom">%una ventana de 15 para tener un buen margen</em>
          minimo=max([1 length(pers_datah)-15]);
          maximo=length(pers_datah);
          <em class="mcom">%Buscamos picos dentro de esa ventana</em>
          peaks=<a class="mfun" href="private/localmaxima.html">localmaxima</a>(pers_datah,2);
          aux=max(pers_datah);
          aux=pers_datah(peaks)/aux;
          peaks=peaks.*(pers_datah(peaks)&gt;0.95).*(pers_datav(peaks)&gt;=9.8).*(aux&gt;0.3); <em class="mcom">%nos quedamos con los positivos y aplicamos las reglas </em>
          <em class="mcom">% heuristicas encontradas (umbrales)</em>
          peaks=peaks(find(peaks&gt;=minimo &amp; peaks&lt;=maximo));
          if(~isempty(peaks))
              <em class="mcom">%Seleccionamos el pico</em>
              <em class="mcom">%Criterio: primer pico seguido de ZC</em>
              evento=peaks(end);
              for j=1:length(peaks)-1
                  if(~isempty(find(pers_datah(peaks(j):peaks(j+1))&lt;0)))
                      <em class="mcom">%hay un paso por cero entre estos ds maximos</em>
                      evento=peaks(j);
                  end
              end
              <em class="mcom">%Calculamos el retardo al evento detectado</em>
              retardo_hs=length(pers_datah)-evento;
              pers_indice_ultimo_hs=evento;
          end
       end
   end
   
   %Comprobamos si tenemos el 15<em class="mcom">% de la señal para buscar un TO</em>
   flag_to=0;
   if(pers_indice_ultimo_hs&gt;0)
      distancia=length(pers_datah)-pers_indice_ultimo_hs;
      if(T~=0)
          if((distancia-2)/T&gt;=0.2) <em class="mcom">%le restamos 2 a distancia para tener algo de margen para el calculo de minimos</em>
             flag_to=1;
             buscamin=floor(0.05*T);
             buscamax=min([ceil(0.15*T),distancia]);
          end
      else
         if(distancia&gt;=14)
             flag_to=1;
             buscamin=2;
             buscamax=14;
         end
      end
   end
   <em class="mcom">%Segun Zijlstra el TO es el minimo local de la aceleracion vertical que</em>
   %se encuentra entre el 5% y el 15<em class="mcom">% del paso</em>
   <em class="mcom">%Aparte, el TO se encuentra despues del FF, que es un maximo global de</em>
   <em class="mcom">%la celeracion vertical</em>
   if(flag_to==1) <em class="mcom">%buscamos el to</em>
          maximos=<a class="mfun" href="private/localmaxima.html">localmaxima</a>(pers_datav(pers_indice_ultimo_hs:end),2);
          minimos=<a class="mfun" href="private/localmaxima.html">localmaxima</a>(-pers_datav(pers_indice_ultimo_hs+buscamin:pers_indice_ultimo_hs+buscamax),2);
          if(~isempty(maximos))
             ff=maximos(1); <em class="mcom">%foot flat</em>
             aux=find((minimos+buscamin)&gt;ff);
             if(~isempty(aux))
                evento=minimos(aux(1))+pers_indice_ultimo_hs+buscamin-1;
                retardo_to=length(pers_datav)-evento;
             end
          end
          pers_indice_ultimo_hs=0;
    end
end
</pre>
<hr size="3" noshade="noshade" />
<!--navigate-->
<!--copyright-->
</body>
</html>
